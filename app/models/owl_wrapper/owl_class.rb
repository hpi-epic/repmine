class OwlClass
  attr_accessor :subclasses, :name, :relations, :attributes, :ontology, :class_url, :superclasses
  SET_OPS = {:sub => "&sub;", :sup => "&sup;", :not => "&not;"}

  include RdfSerialization
  
  # will return the same instance for the given parameters
  def self.find_or_create(ontology, name, url)
    (@instances ||= Hash.new)[[ontology, name, url]] ||= self.new(ontology, name, url)
  end
  
  def initialize(ontology, name, url)
    @subclasses = Set.new
    @superclasses = Set.new    
    @ontology = ontology
    @name = name
    @relations = Set.new
    @attributes = Set.new
    @class_url = url
    ontology.add_class(self) unless ontology.nil?
  end
  
  def add_subclass(owl_class)
    @subclasses << owl_class
    owl_class.superclasses << self
  end

  def add_attribute(name, sample_value)
    a = DatatypeProperty.from_sample(name, self, sample_value)
    attributes << a
    return a
  end

  def add_relation(name, target_class)
    r = ObjectProperty.new(name, self, target_class)
    relations << r
    return r
  end

  def url
    return class_url || (ontology.url + "/" + name)
  end

  def rdf_statements
    stmts = [
      [resource, RDF.type, RDF::OWL.Class],
      [resource, RDF::RDFS.isDefinedBy, RDF::Resource.new(ontology.url)],
      [resource, RDF::RDFS.label, RDF::Literal.new(name)],
      [resource, RDF::RDFS.comment, RDF::Literal.new("Class generated by ontology extractor.")]
    ]
    relations.each{|rel| stmts.concat(rel.rdf)}
    attributes.each{|att| stmts.concat(att.rdf)}
    return stmts
  end

  def ==(other_object)
    return self.url == other_object.url
  end
end